"""
Script that reads in models.py and generates pymodels.py
"""


import re
import ast
import string

INPUT='src/models.py'
OUTPUT='src/pymodels.py'

# Parser states
START=0
INCLASS=1
OUTOFCLASS=2

indent_level=0
indent_sequence=''

pymodelbase = """# This file was auto-generated by generate_pymodels.py

import models

class PyModelBase:
    
    @staticmethod
    def __import__(data):
        raise NotImplementedError
        
    def __export__(self):
        raise NotImplementedError
    
    def __eq__(self, other):
        return self.__dict__ == other.__dict__
    
    def __cmp__(self, other):
        return self.__dict__ == other.__dict__

"""

def generateClass(variables):
    template="""
class ${NAME:&}(PyModelBase):
    def __init__(self, ${FIELDS:&:, }):
        ${FIELDS:self.&=&:\\n        }
        
    @staticmethod
    def __import__(data):
        if type(data) is not models.${NAME:&} or data is None:
            raise Exception("Invalid argument to __import__")

        return ${NAME:&}(${FIELDS:data.&:, })
        
    def __export__(self):
        return models.${NAME:&}(${FIELDS:&=self.&:, })

"""
    
    for var in variables:
        pattern = r'\$\{{({0}.*?)\}}'.format(var)
        match = re.search(pattern, template)
        while match:
            fields = match.group(1).split(':')
            if type(variables[var]) is list:
                subst = ast.literal_eval("'" + fields[2] + "'").join([re.sub(r'(?<!\\)&', x, ast.literal_eval("'" + fields[1] + "'")) for x in variables[var]])
                template = template[0:match.start()] + subst + template[match.end():]
            elif type(variables[var]) is str:
                subst = re.sub(r'(?<!\\)&', variables[var], ast.literal_eval("'" + fields[1] + "'"))
                template = template[0:match.start()] + subst + template[match.end():]
            else:
                raise Exception("Invalid variable type")
            match = re.search(pattern, template)
            
    return template

if __name__=="__main__":
    with open(INPUT, 'r') as infile:
        infileText = infile.readlines()
    state = START
    with open(OUTPUT, 'w+') as outfile:
        outfile.write(pymodelbase)
        variables = {}
        variables["FIELDS"] = []
        for line in infileText:
            if line.startswith('class'):
                if state == INCLASS:
                    outfile.write(generateClass(variables))
                    variables = {}
                    variables["FIELDS"] = []
                variables["NAME"] = line.split(' ')[1].split('(')[0].strip()
                if state == START or state == OUTOFCLASS:
                    state = INCLASS
            elif state == INCLASS:
                if line.strip() != '':
                    # If the line is not blank, assume it is an attribute
                    if re.match(r'\s+', line) is not None and re.match(r'\s*#', line) is None:
                        attrib = line.strip().split('=')[0].strip()
                        if not attrib.startswith('__'):
                            variables["FIELDS"].append(attrib)
                    else:
                        state = OUTOFCLASS
                        outfile.write(generateClass(variables))
                        variables = {}
                        variables["FIELDS"] = []